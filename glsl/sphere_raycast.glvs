#version 150

struct sphere_parameter_space
{
    vec3  m_tilde;
    vec3  x_tilde;
    vec3  y_tilde;
    vec3  e_tilde;
    
};

uniform float radius;

in vec4  position;
in vec4  color;

out mat3  NM;
out mat4  MV;
out mat4  MVP;
out vec4  color_gs;
out sphere_parameter_space sps;


//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************


void main()
{
    // compute normal transformation matrix
    NM = get_normal_matrix();
    // compute position transformation matrix
    MV = get_modelview_matrix();
    MVP = get_modelview_projection_matrix();
    // compute sphere color
    color_gs = color;


    /************************************************************************************
     tasks 2.1:  Use the vertex shader to compute variables that are invariant for the 
                 whole sphere, such as silhouette parameter in parameter space (sphere
                 center at origin)*/

     /*<your_code_here>*/

	 mat4 mv_i = get_inverse_modelview_matrix();
	 sps.e_tilde = vec3(mv_i[0][3], mv_i[1][3], mv_i[2][3]);

	 vec3 diff = vec3(sps.e_tilde[0] - position[0], sps.e_tilde[1] - position[1], sps.e_tilde[2] - position[2]);
	 float e = sqrt(diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]);
	 float m = radius * radius / e;
	 sps.m_tilde = m / e * diff;

	 sps.x_tilde = vec3(1, 0, 0);
	 sps.y_tilde = vec3(0, 1, 0);


    /************************************************************************************/

}