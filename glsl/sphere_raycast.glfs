#version 150 

uniform int culling_mode = 0;
uniform int map_color_to_material = 0;
uniform int illumination_mode = 2;

uniform float radius;

struct sphere_quad_info
{
    vec2 q_tilde;
    
};

in sphere_quad_info quad;

in vec4 color_fs;

in vec4 position;


//***** begin interface of surface.glsl ***********************************
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
//***** end interface of surface.glsl ***********************************

//***** begin interface of fragment.glfs ***********************************
uniform float gamma = 2.2;
void finish_fragment(vec4 color);
//***** end interface of fragment.glfs ***********************************


bool compute_ray_sphere_intersection(out vec3 p_eye, out vec3 n_eye)
{
    /************************************************************************************
     tasks 2.1b:  Determine if the ray intersects with the sphere. You can use q_tilde
                  for an easy intersection test based on texture coordinates.*/

     /*<your_code_here>*/
	 float q_length_sq = quad.q_tilde[0]+quad.q_tilde[0] + quad.q_tilde[1]+quad.q_tilde[1];
	 if(q_length_sq > 1)
		return false;

    /************************************************************************************/

    /************************************************************************************
     tasks 2.1c:  Compute the position (p_eye) and the normal (n_eye) of the intersection
                  point in eye coordinates.*/
	 
     /*<your_code_here>*/
	 vec3 diff = vec3(p_eye[0] - position[0], p_eye[1] - position[1], p_eye[2] - position[2]);
	 float length_diff = sqrt(diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]);
	 float beta = radius * sqrt(1.0 - q_length_sq) / length_diff;
	 float lambda = 1.0 / (1.0 + beta);

	 p_eye = p_eye + lambda * n_eye;
	 
	 diff = vec3(p_eye[0] - position[0], p_eye[1] - position[1], p_eye[2] - position[2]);
	 length_diff = sqrt(diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]);
	 n_eye = 1 / length_diff * diff;

    /************************************************************************************/

    /************************************************************************************
     tasks 2.1d:  Update gl_FragDepth with the corrected depth value for the intersection
                  point.*/

     /*<your_code_here>*/

    /************************************************************************************/

    return true;
}

void main()
{
    vec3 p_eye;     // position in eye coordinates
    vec3 n_eye;     // normal in eye coordinates

    if (!compute_ray_sphere_intersection(p_eye, n_eye))
        discard;

    // computes the color based on the point and normal in eye coordinates and
    // a specified color (color_fs)
    vec4 color = compute_reflected_appearance(p_eye, n_eye, color_fs, 1);
    finish_fragment(color);
}