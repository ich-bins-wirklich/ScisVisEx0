#version 150
#extension GL_EXT_geometry_shader4 : enable

struct sphere_parameter_space
{
    vec3  m_tilde;
    vec3  x_tilde;
    vec3  y_tilde;
    vec3  e_tilde;
    
};

struct sphere_quad_info
{
    vec2 q_tilde;
    
};


uniform float pixel_extent_per_depth;

in mat3 NM[];
in mat4 MV[];
in mat4 MVP[];
in sphere_parameter_space sps[];
in vec4  color_gs[];

out vec4  color_fs;
out sphere_quad_info quad;


/// emits one vertex of the sphere quad depending on the sphere center and the current corner
/// t(-1,1)  y   t(1,1)
///      o---|---o
///      |   |___|x
///      |       |
///      o-------o
/// t(-1,-1)     t(-1,1)
void generate_quad_vertex(in vec4 sphere_center, in vec2 t, in sphere_parameter_space sps, in mat4 MV, in mat4 MVP, in mat3 NM)
{
    // use texture coordinates for easy intersection test
    quad.q_tilde = t;

    /************************************************************************************
     tasks 2.1:  Compute the positions of the quad corners and set it as gl_Position in 
                 clip coordinates. You may want to compute some other variables here as well.*/

     /*<your_code_here>*/

    /************************************************************************************/

    EmitVertex();
}


void generate_sphere_cover_quad(in vec4 sphere_center, in sphere_parameter_space sps, in mat4 MV, in mat4 MVP, in mat3 NM, in float splat_size = 1.0)
{
    
    generate_quad_vertex(sphere_center, vec2(-1, -1), sps, MV, MVP, NM);
    generate_quad_vertex(sphere_center, vec2( 1, -1), sps, MV, MVP, NM);
    generate_quad_vertex(sphere_center, vec2(-1,  1), sps, MV, MVP, NM);
    generate_quad_vertex(sphere_center, vec2( 1,  1), sps, MV, MVP, NM);
    EndPrimitive();
}


void main()
{
    color_fs = color_gs[0];

    // emits the corners of a rectangle covering the silhouette of a sphere
    generate_sphere_cover_quad(gl_PositionIn[0], sps[0], MV[0], MVP[0], NM[0]);
}